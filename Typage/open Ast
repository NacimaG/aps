open Ast
open Printf

type value = InN of int 
    	|InF of expr * (string list)* env   (* env c'est pour capter l environement à l instant ou la fonction a été declaréé *)
		|InFR of expr * (string list)* env * string

and env = (string * value) list;;


let rec listarg e = 
	match e with 
		|[] -> []
		|ASTArg(x,t)::f -> x::(listarg f)
		;; 
			


let pi op e =
	match op with 
		| "not"  -> begin match e with
						| (0,_)  -> 1
						| (1,_)  -> 0 end
		| "and" -> begin match e with 
							| (0 , n) -> 0
							| (n , 0) -> 0 
							| (n , 1) -> n
							| (1 , n) -> n
							end	
		| "or" -> begin match e with 
							| (0 , n) -> n
							| (n , 0) -> n 
							| (n , 1) -> 1
							| (1 , n) -> 1
							end
		| "eq" -> begin match e with 
							| (n1 , n2) when n1=n2 -> 1
							| (n1 , n2) when n1<>n2 -> 0
							end
		| "lt" ->begin match e with 
							| (n1 , n2) when n1<n2 -> 1
							| (n1 , n2) when n1>n2 -> 0
							end
		| "add" ->begin match e with (n1 , n2) ->  n1 + n2 end 
		| "sub" ->begin match e with (n1 , n2) -> n1 - n2 end 
		| "mul" ->begin match e with (n1 , n2) -> n1 * n2 end 
		| "div" ->begin match e with (n1 , n2) -> n1 / n2 end



 (* fonction manipulant l environement *)

and v n =
	n


and appendEnv env e =

	List.append [e] env

;;

let rec appendArgsValsEnv env (args,vals) =
	match (args,vals) with 
	[],[] -> env
	|x::xs, y::ys -> (x, (eval_expr env y))::appendArgsValsEnv env (xs,ys)  



and getValEnv env x =
	match env with
	[] -> raise Not_found
	| (k,v)::_ when k = x -> v
	| _::q -> getValEnv q x


and eval_expr env e =
	match e with 
			ASTTrue -> InN(1)
			|ASTFalse -> InN(0)
			|ASTNum n -> InN(v(n))
			|ASTId x -> getValEnv env x 
			|ASTPrim(op, e1, e2) -> let x = (string_of_op op)
									and InN(v1) = eval_expr env e1
									and InN(v2) = eval_expr env e2
									in InN(pi x (v1, v2))
			|ASTUPrim(uop, e1) ->  let x =  (string_of_uop uop)
									and  InN(v) = eval_expr env e1
									in InN (pi x (v,1)) 	
									
			|ASTIf(e1,e2,e3) ->( if (eval_expr env e1) = InN(1) then 
								let InN(v1) = (eval_expr env e2)
								in InN(v1)
								else 
								let InN(v2) = (eval_expr env e3)
								in InN(v2)
			)
			|ASTExprs(e1,e2) ->(
				let ASTId (f) = e1 in 
				let e = getValEnv env f in
				match e with
				| InF(e,args,envC) -> ( let new_env =  appendArgsValsEnv env (args,e2) in
										eval_expr new_env e
				)
				|InFR(e,args,envC,x) -> ( let new_env =  appendArgsValsEnv env (args,e2) in
										  eval_expr new_env e
				) 
			)
	


and eval_exprlist env e =
		match e with
			[] -> []
			|d::f ->(	 
				(eval_expr env d)::(eval_exprlist env f) 
			)


and eval_stat env e =
	match e with 
			ASTEcho(e1) -> let InN(n)= (eval_expr env e1) in Printf.printf "%d\n" n


and eval_dec env e =
	match e with 
		|ASTConst(e1,e2,e3)-> let InN(n) = (eval_expr env e3) in  
							 appendEnv env (e1,InN(n))
		|ASTFun(e1,e2,e3,e4) -> let args = listarg e3 in
		appendEnv env (e1,InF(e4,args,env))
		|ASTFunRec(e1,e2,e3,e4) -> let args = listarg e3 in
		appendEnv env (e1,InFR(e4,args,env,e1))
					

and eval_cmds env e =
	match e with 
		|ASTCmds(e1)->(
			eval_stat env e1
		)
		|ASTCmdsDec(e1,e2)->(
			let envP = eval_dec env e1 in
			eval_cmds envP e2

		)
		|ASTCmdsStat(e1,e2)->(
			eval_stat env e1;
			eval_cmds env e2
					)


and eval_prog env e =
match e with
	|ASTProg(e1)->(
		eval_cmds env e1
)

let _ = 
	try 
		let f = open_in "test.aps" in 
		let lexbuf = Lexing.from_channel f in 
		let e = Parser.line Lexer.token lexbuf in
		eval_prog [] e;
		print_char '\n'
	with Lexer.Eof -> exit 0

;;
v